\documentclass[a4paper,12pt,openright]{book}
%\documentclass[a4paper, 12pt, openright, draft]{book}  Nalogo preverite tudi z opcijo draft, ki pokaže, katere vrstice so predolge! Pozor, v draft opciji, se slike ne pokažejo!
 
\usepackage[utf8]{inputenc}
\usepackage[slovene,english]{babel}
\usepackage[pdftex]{graphicx}
\usepackage{fancyhdr}
\usepackage{amssymb}
\usepackage{amsmath}           % eqref, npr.
\usepackage{hyperxmp}
\usepackage[hyphens]{url}
\usepackage{csquotes}
\usepackage[pdftex, colorlinks=true,
						citecolor=black, filecolor=black, 
						linkcolor=black, urlcolor=black,
						pdfproducer={LaTeX}, pdfcreator={LaTeX}]{hyperref}

\usepackage{color}
\usepackage{soul}
\usepackage{array}
\usepackage{tikz}
\usepackage{listings}

\tikzstyle{arrow} = [thick,->,>=stealth]

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\lstset{
	backgroundcolor=\color{backcolour},   
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
	breaklines=true,
	tabsize=4,
	numbers=left
}

\usepackage[
backend=biber,
style=numeric,
sorting=nty,
]{biblatex}

\addbibresource{bibliography.bib}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%	DIPLOMA INFO
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newcommand{\ttitle}{Primerjava sistemskih klicev Linux in Windows}
\newcommand{\ttitleEn}{The comparison of Linux and Windows system calls}
\newcommand{\tsubject}{\ttitle}
\newcommand{\tsubjectEn}{\ttitleEn}
\newcommand{\tauthor}{Miha Meglič}
\newcommand{\tkeywords}{sistemski klic, linux, windows, operacijski sistem}
\newcommand{\tkeywordsEn}{system call, linux, windows, operating system}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%	HYPERREF SETUP
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\hypersetup{pdftitle={\ttitle}}
\hypersetup{pdfsubject=\ttitleEn}
\hypersetup{pdfauthor={\tauthor}}
\hypersetup{pdfkeywords=\tkeywordsEn}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% postavitev strani
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%  

\addtolength{\marginparwidth}{-20pt} % robovi za tisk
\addtolength{\oddsidemargin}{40pt}
\addtolength{\evensidemargin}{-40pt}

\renewcommand{\baselinestretch}{1.3} % ustrezen razmik med vrsticami
\setlength{\headheight}{15pt}        % potreben prostor na vrhu
\renewcommand{\chaptermark}[1]%
{\markboth{\MakeUppercase{\thechapter.\ #1}}{}} \renewcommand{\sectionmark}[1]%
{\markright{\MakeUppercase{\thesection.\ #1}}} \renewcommand{\headrulewidth}{0.5pt} \renewcommand{\footrulewidth}{0pt}
\fancyhf{}
\fancyhead[LE,RO]{\sl \thepage} 
%\fancyhead[LO]{\sl \rightmark} \fancyhead[RE]{\sl \leftmark}
\fancyhead[RE]{\sc \tauthor}
\fancyhead[LO]{\sc Diplomska naloga}


\newcommand{\BibLaTeX}{{\sc Bib}\LaTeX}
\newcommand{\BibTeX}{{\sc Bib}\TeX}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% naslovi
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%  

\newcommand{\autfont}{\Large}
\newcommand{\titfont}{\LARGE\bf}
\newcommand{\clearemptydoublepage}{\newpage{\pagestyle{empty}\cleardoublepage}}
\setcounter{tocdepth}{1}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% konstrukti
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%  
\newtheorem{izrek}{Izrek}[chapter]
\newtheorem{trditev}{Trditev}[izrek]
\newenvironment{dokaz}{\emph{Dokaz.}\ }{\hspace{\fill}{$\Box$}}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% PDF-A
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
% define medatata
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
\def\Title{\ttitle}
\def\Author{\tauthor, miha@meglic.dev}
\def\Subject{\ttitleEn}
\def\Keywords{\tkeywordsEn}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
% \convertDate converts D:20080419103507+02'00' to 2008-04-19T10:35:07+02:00
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
\def\convertDate{%
    \getYear
}

{\catcode`\D=12
 \gdef\getYear D:#1#2#3#4{\edef\xYear{#1#2#3#4}\getMonth}
}
\def\getMonth#1#2{\edef\xMonth{#1#2}\getDay}
\def\getDay#1#2{\edef\xDay{#1#2}\getHour}
\def\getHour#1#2{\edef\xHour{#1#2}\getMin}
\def\getMin#1#2{\edef\xMin{#1#2}\getSec}
\def\getSec#1#2{\edef\xSec{#1#2}\getTZh}
\def\getTZh +#1#2{\edef\xTZh{#1#2}\getTZm}
\def\getTZm '#1#2'{%
    \edef\xTZm{#1#2}%
    \edef\convDate{\xYear-\xMonth-\xDay T\xHour:\xMin:\xSec+\xTZh:\xTZm}%
}

%\expandafter\convertDate\pdfcreationdate 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% get pdftex version string
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% 
\newcount\countA
\countA=\pdftexversion
\advance \countA by -100
\def\pdftexVersionStr{pdfTeX-1.\the\countA.\pdftexrevision}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% XMP data
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%  
\usepackage{xmpincl}
%\includexmp{pdfa-1b}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% pdfInfo
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%  
\pdfinfo{%
    /Title    (\ttitle)
    /Author   (\tauthor, miha@meglic.dev)
    /Subject  (\ttitleEn)
    /Keywords (\tkeywordsEn)
    /ModDate  (\pdfcreationdate)
    /Trapped  /False
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% znaki za copyright stran
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%  

\newcommand{\CcImageCc}[1]{%
	\includegraphics[scale=#1]{resources/cc_cc_30.pdf}%
}
\newcommand{\CcImageBy}[1]{%
	\includegraphics[scale=#1]{resources/cc_by_30.pdf}%
}
\newcommand{\CcImageSa}[1]{%
	\includegraphics[scale=#1]{resources/cc_sa_30.pdf}%
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}
\selectlanguage{slovene}
\frontmatter
\setcounter{page}{1} %
\renewcommand{\thepage}{}       % preprečimo težave s številkami strani v kazalu

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%naslovnica
\thispagestyle{empty}%
\begin{center}
	{\large\sc Univerza v Ljubljani\\
		Fakulteta za računalništvo in informatiko\\
	}
	\vskip 10em
	{\autfont \tauthor\par}
	{\titfont \ttitle \par}
	{\vskip 3em \textsc{DIPLOMSKO DELO\\[5mm]
		UNIVERZITETNI  ŠTUDIJSKI PROGRAM\\ PRVE STOPNJE\\ RAČUNALNIŠTVO IN INFORMATIKA}\par}
	\vfill\null
	{\large \textsc{Mentor}: doc. dr. Jurij Mihelič\par}
	{\vskip 2em \large Ljubljana, \the\year \par}
\end{center}
% prazna stran
%\clearemptydoublepage      
% izjava o licencah itd. se izpiše na hrbtni strani naslovnice

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%copyright stran
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newpage
\thispagestyle{empty}

\vspace*{5cm}
{\small \noindent
	To delo je ponujeno pod licenco \textit{Creative Commons Priznanje avtorstva-Deljenje pod enakimi pogoji 2.5 Slovenija} (ali novej\v so razli\v cico).
	To pomeni, da se tako besedilo, slike, grafi in druge sestavine dela kot tudi rezultati diplomskega dela lahko prosto distribuirajo,
	reproducirajo, uporabljajo, priobčujejo javnosti in predelujejo, pod pogojem, da se jasno in vidno navede avtorja in naslov tega
	dela in da se v primeru spremembe, preoblikovanja ali uporabe tega dela v svojem delu, lahko distribuira predelava le pod
	licenco, ki je enaka tej.
	Podrobnosti licence so dostopne na spletni strani \href{http://creativecommons.si}{creativecommons.si} ali na Inštitutu za
	intelektualno lastnino, Streliška 1, 1000 Ljubljana.
																																																																																																																																																																																																																																																																																																																																																																																																																																	
	\vspace*{1cm}
	\begin{center}% 0.66 / 0.89 = 0.741573033707865
		\CcImageCc{0.741573033707865}\hspace*{1ex}\CcImageBy{1}\hspace*{1ex}\CcImageSa{1}%
	\end{center}
}

\vspace*{1cm}
{\small \noindent
	Izvorna koda diplomskega dela, njeni rezultati in v ta namen razvita programska oprema je ponujena pod licenco GNU General Public License,
	različica 3 (ali novejša). To pomeni, da se lahko prosto distribuira in/ali predeluje pod njenimi pogoji.
	Podrobnosti licence so dostopne na spletni strani \url{http://www.gnu.org/licenses/}.
}

\vfill
\begin{center} 
	\ \\ \vfill
	{\em
		Besedilo je oblikovano z urejevalnikom besedil \LaTeX.}
\end{center}

% prazna stran
\clearemptydoublepage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% stran 3 med uvodnimi listi
\thispagestyle{empty}
\
\vfill

\bigskip
\noindent\textbf{Kandidat:} \tauthor\\
\noindent\textbf{Naslov:} \ttitle\\
\noindent\textbf{Vrsta naloge:} Diplomska naloga na univerzitetnem programu prve stopnje Računalništvo in informatika \\
\noindent\textbf{Mentor:} doc. dr. Jurij Mihelič

\bigskip
\noindent\textbf{Opis:}\\
Besedilo teme diplomskega dela študent prepiše iz študijskega informacijskega sistema, kamor ga je vnesel mentor. 
V nekaj stavkih bo opisal, kaj pričakuje od kandidatovega diplomskega dela. 
Kaj so cilji, kakšne metode naj uporabi, morda bo zapisal tudi ključno literaturo.

\bigskip
\noindent\textbf{Title:} \ttitleEn

\bigskip
\noindent\textbf{Description:}\\
opis diplome v angleščini

\vfill



\vspace{2cm}

% prazna stran
\clearemptydoublepage

% zahvala
\thispagestyle{empty}\mbox{}\vfill\null\it%
\noindent
Na tem mestu zapišite, komu se zahvaljujete za pomoč pri izdelavi diplomske naloge oziroma pri vašem študiju nasploh. Pazite, da ne boste koga pozabili. Utegnil vam bo zameriti. Temu se da izogniti tako, da celotno zahvalo izpustite.
\rm\normalfont

% prazna stran
\clearemptydoublepage


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% kazalo
\pagestyle{empty}
\def\thepage{}% preprečimo težave s številkami strani v kazalu
\tableofcontents{}


% prazna stran
\clearemptydoublepage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% seznam kratic

\chapter*{Seznam uporabljenih kratic}

\noindent\begin{tabular}{p{0.11\textwidth}|p{.39\textwidth}|p{.39\textwidth}}    % po potrebi razširi prvo kolono tabele na račun drugih dveh!
{\bf kratica}	& {\bf angleško}							& {\bf slovensko} \\ \hline
{\bf OS}		& Operating System							& operacijski sistem \\
{\bf API}		& Application Programming Interface			& vmesnik uporabniškega programa \\
{\bf POSIX}		& Portable Operating System Interface		& prenosni vmesnik za operacijski sistem \\
\end{tabular}


% prazna stran
\clearemptydoublepage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% povzetek
\addcontentsline{toc}{chapter}{Povzetek}
\chapter*{Povzetek}

\noindent\textbf{Naslov:} \ttitle
\bigskip

\noindent\textbf{Avtor:} \tauthor
\bigskip

%\noindent\textbf{Povzetek:} 
\noindent V vzorcu je predstavljen postopek priprave diplomskega dela z uporabo okolja \LaTeX. Vaš povzetek mora sicer vsebovati približno 100 besed, ta tukaj je odločno prekratek.
Dober povzetek vključuje: (1) kratek opis obravnavanega problema, (2) kratek opis vašega pristopa za reševanje tega problema in (3) (najbolj uspešen) rezultat ali prispevek diplomske naloge.

\bigskip

\noindent\textbf{Ključne besede:} \tkeywords.
% prazna stran
\clearemptydoublepage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% abstract
\selectlanguage{english}
\addcontentsline{toc}{chapter}{Abstract}
\chapter*{Abstract}

\noindent\textbf{Title:} \ttitleEn
\bigskip

\noindent\textbf{Author:} \tauthor
\bigskip

%\noindent\textbf{Abstract:} 
\noindent This sample document presents an approach to typesetting your BSc thesis using \LaTeX. 
A proper abstract should contain around 100 words which makes this one way too short.
\bigskip

\noindent\textbf{Keywords:} \tkeywordsEn.
\selectlanguage{slovene}
% prazna stran
\clearemptydoublepage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\mainmatter
\setcounter{page}{1}
\pagestyle{fancy}

\chapter{Uvod}


\chapter{Teorija}

Moderni računalniki vsebujejo mnogo različnih komponent in se povezujejo na razno razne vhodno izhodne naprave.
Pri takem obsegu in kompleksnosti računalniških sistemov je praktično nepredstavljivo, da bi vsak programer poznal vse podrobnosti delovanja vseh komponent.
Zato se je pojavila potreba po programu, katerega naloga je upravljanje z viri sistema in abstrakcija dostopa do le teh -- \textbf{operacijski sistem}.

Večina modernih procesorjev ima vsaj dva načina delovanja: \textbf{uporabniški} in \textbf{jedrni} (oz. privilegiran) način.
Operacijski sistem se (večinoma) izvaja v jedrnem načinu, kjer ima dostop do vseh virov sistema in lahko izvede kateri koli ukaz v ukaznem naboru procesorja.
Preostanek programske opreme pa se izvaja v uporabniškem načinu, kjer ima dostop le do omejenega ukaznega nabora.

Kot smo že omenili, je naloga operacijskega sistema upravljanje z viri sistema in abstrakcija dostopa do strojne opreme.
Upravljanje z viri je tako uporabniku kot tudi programerju skrito in v večini transparentno, saj se izvaja avtomatsko in v ozadju.
Abstrakcija dostopa do strojne opreme pa je implementirana s \textbf{sistemskimi klici}.
\cite{Tanenbaum_Bos_2023}

\section{Pregled operacijskih sistemov}

\subsection{Linux}

Linux izgleda in se obnaša podobno kot kateri koli drug UNIX sistem, saj je bil eden izmed glavnih ciljev pri razvoju skladnost s standardi POSIX in Single UNIX.
Razvoj sistema se je začel leta 1991, ko je Finski študent Linus Torvalds začel razvijati majhno jedro za procesor 80386 -- prvi pravi 32-bitni procesor v Intelovem naboru.

Zgodaj v razvoju je bila Linux izvorna koda javno objavljena in je kmalu pritegnila veliko skupnost programerjev, ki so prispevali k razvoju jedra in programske opreme.
Sistem je hitro zrasel iz majhne nepopolne replike UNIX sistema v popolnoma funkcionalen moderen operacijski sistem.

Seveda pa je pomembno omeniti, da je Linux samo jedro operacijskega sistema.
Za celoten operacijski sistem pa potrebujemo še uporabniško programsko opremo, ki ji danes pravimo distribucija.
Ta vsebuje vse standardne komponente Linux sistema in doda administrativna orodja, ki poenostavijo namestitev, nadgradnjo in vzdrževanje sistema ter omogočajo delo z datotečnim sistemom, kreiranje in upravljanje uporabniških računov, administracijo omrežij in mnogo več.
Prav tako ponuja programe, ki nam omogočajo namestitev dodatnih programov in orodij, ki jih uporabnik potrebuje.
Veliko izmed teh programov je bilo razvitih v sklopu odprtokodnih projektov, kot so GNU, BSD, X Window System, itd.
\cite{Silberschatz_Galvin_Gagne_2018}

\subsubsection{Linux jedro}

Prvo Linux jedro (verzija 0.01) je bilo javno izdano 14. maja 1991. Ni podpiralo omrežij in delovalo je le na procesorjih kompatibilnih z Intel 80386.
Podpora za strojno opremo je bila zelo omejena in podprt je bila samo Minix datotečni sistem.

Naslednji mejnik, Linux 1.0, je bil izdan 14. marca 1994. Dodana je bila podpora za TCP/IP omrežne protokole in BSD kompatibilna implementacija vtičnic (\textit{angl. socket}).
Drastično je bila izboljšana tudi podpora za strojno opremo, dodana je bila podpora disketne pogone, CD-ROM naprave, zvočne kartice, miške in mednarodne tipkovnice.
Prav tako je bila dodana podpora za več procesorjev, vendar še vedno omejena na Intel procesorje.
Omembe vredni so še podpora za deljen pomnilnik, semaforje, sporočilne vrste in, kot že omenjeno, medprocesno komunikacijo.

V sledečih verzija je bila sčasoma dodana podpora za nove arhitekture procesorjev, kot so DEC Alpha, Sun SPARC in MIPS ter kasneje še PowerPC, ARM in mnoge druge.
\cite{Silberschatz_Galvin_Gagne_2018}

\subsubsection{Linux Virtual File System}

Navidezni datotečni sistem (\textit{angl. Virtual File System -- abbr. VFS}) je programska plast v jedru, ki omogoča uporabnikom in uporabniškim programom dostop do različnih datotečnih sistemov.
Deluje pa tudi kot abstrakcija znotraj jedra, ki omogoča sobivanje različnih datotečnih sistemov.

VFS implementira vse funkcionalnosti, ki jih pričakujemo od datotečnega sistema, kot so branje in pisanje datotek, ustvarjanje in brisanje datotek, itd.
Pot do imenika, ki je podana omenjenim ukazom, se v VFS preko predpomnilnika imeniških vnosov (\textit{angl. dentry cache / dcache}) pretvori v imeniški vnos (\textit{angl. dentry}).
Ta mehanizem omogoča zelo hitro prevedbo poti v imeniški vnos, saj se izognemo branju iz diska, če seveda je imeniški vnos na voljo v predpomnilniku.

Vsak imeniški vnos vsebuje kazalec na indeksno vozlišče (\textit{angl. inode}). Indeksna vozlišča so objekti datotečnega sistema (npr. datoteke, imeniki, naprave), ki bivajo na disku (za datotečne sisteme blokovnih naprav) ali v pomnilniku (za pseudo datotečne sisteme).
Indeksna vozlišča, ki bivajo na disku se, po potrebi, kopirajo v pomnilnik, spremembe pa se zapišejo nazaj na disk.
Eno indeksno vozlišče lahko pripada več imeniškim vnosom, kar omogoča, da se datoteka prikaže na več različnih mestih v imeniku.
\cite{Linux_kernel_docs_LVFS}

VFS omogoča UNIX koncept ``everything is a file'', kjer je osnovna ideja, da se vsi sistemski resursi (npr. naprave, procesi, omrežje) predstavijo kot datoteke.
To omogoča enoten način dostopa do sistemskih virov, kar olajša uporabo in razvoj programske opreme in zmanjša število potrebnih sistemskih klicev.

\subsection{Windows}

TODO: ANSI in Unicode ukazi, omemba teže NT jedra v imenu kompatibilnosti, razvoj (zgodovina) NT jedra

\section{Sistemski klici}

Sistemski klici so vmesnik do storitev, ki jih ponuja jedro operacijskega sistema, kot na primer ustvarjanje procesov, branje in pisanje datotek, komunikacijo med procesi, itd.
Ker torej sistemski klici prehajajo med uporabniškim in jedrnim načinom procesorja, je njihova implementacija odvisna od arhitekture procesorja in njegovega nabora ukazov.

Ker pa jih uporabniški programi potrebujejo dokaj pogosto, so v večini operacijskih sistemov izpostavljeni preko knjižnice ali API-ja.
Najbolj pogosto uporabljena API-ja za aplikacijske programerje sta \textbf{POSIX}, za sisteme, ki sledijo POSIX standardu, npr. Unix, Linux in macOS, in \textbf{Windows API}, za Windows sisteme.
Programer do API-ja dostopa preko knjižnice, ki jo ponuja operacijski sistem -- npr. libc za programski jezik C, v primeru Linuxa.
Tu je omembe vredno tudi, da imena funkcij v knjižnici niso nujno enaka imenom sistemskih klicev, ki jih uporablja sistem.
\cite{Silberschatz_Galvin_Gagne_2018}

Kljub temu, da iz uporabniške oz. programske strani sistemski klici izgledajo kot navadne funkcije, je njihova implementacija popolnoma drugačna:
\begin{enumerate}
	\item Uporabniški proces (oz. knjižnica, ki jo uporablja) shrani številko sistemskega klica in argumente funkcije v registre procesorja -- registri se razlikujejo glede na arhitekturo in OS.
	\item Uporabniški proces sproži past, ki preklopi procesor v jedrni način in požene prekinitveni servisni program (ISR), ki ga je definiral operacijski sistem.
	\item Jedro izvede zahtevan sistemski klic in vrne rezultat -- rezultat se zapiše v register iz katerega ga uporabniški program lahko prebere.
	\item Procesor preklopi nazaj v uporabniški način in nadaljuje izvajanje uporabniškega procesa. \cite{Tanenbaum_Bos_2023}
\end{enumerate}

Preden pa se podamo v primerjave posameznih sistemskih klicev, si poglejmo še, kakšne so implementacijske razlike med sistemskimi klici v Linuxu in Windowsu.
Tu še enkrat poudarjam, da so razlike med sistemskimi klici odvisne od arhitekture procesorja.
V vseh konkretnih primerih bom uporabljal ukazni nabor in imena registrov arhitekture \textbf{x86}.

\subsection{Linux -- POSIX API}

Ker je Linux jedro odprtokodno, si lahko pogledamo tabelo sistemskih klicev, ki jih ponuja na \textbf{x86-64} arhitekturi.
Ta je dostopna v datoteki \texttt{arch/x86} \texttt{/entry/syscalls/syscall\_64.tbl} v \href{https://github.com/torvalds/linux}{izvorni kodi jedra}.
Tu lahko opazimo, da je arhitektura procesorja del poti do datoteke in če pogledamo v druge imenike v \texttt{arch}, lahko vidimo, da ima vsaka implementirana arhitektura med drugim tudi svojo tabelo sistemskih klicev.

Omenili smo že, da Linux implementira POSIX standard, ki definira procedure, ki naj bi jih implementiral operacijski sistem.
V veliki večini te procedure zahtevajo uporabo sistemskih, vendar je potrebno poudariti, da povezava ni nujno ena na ena.
Lahko se zgodi, da neka procedura sploh ne zahteva uporabe sistemskih klicev, v katerem primeru je implementirana v uporabniškem načinu, ali pa zahteva uporabo več sistemskih klicev.
V redkem primeru se lahko zgodi, da več funkcij uporablja isti, bolj splošen, sistemski klic.

\subsection{Windows -- Windows API}

Windows je, v kontrastu z Linuxom, zaprtokodni operacijski sistem, zato je težje priti do podatkov o njegovi implementaciji.
Ena izmed glavnih razlik je, da Windows omogoča dostop do sistemskih klicev izključno preko Windows API-ja.
Torej, če smo v Linuxu lahko pokukali v tabelo sistemskih klicev in jih lahko celo poklicali direktno z zbirnim jezikom, je v Windowsu to nemogoče.

Še ena velika razlika, ki jo bomo srečavali v naslednjem poglavju, je število API procedur.
Windows API izpostavi ogromno procedur, v rangu več tisoč, medtem ko POSIX API izpostavi le nekaj sto.
To je posledica več faktorjev -- pogosto več funkcij uporablja isti sistemski klic, veliko pa je tudi funkcij, ki so v celoti implementirane v uporabniškem načinu.

Ker Windows ne izpostavi sistemskih klicev direktno, se lahko le-te spreminjajo med posameznimi verzijami operacijskega sistema.
To pomeni, da je težko zagotovo reči ali je neka funkcija implementirana v uporabniškem ali jedrnem načinu.
\cite{Tanenbaum_Bos_2023}

\chapter{Primerjava sistemskih klicev}

Ker je sistemskih klicev ogromno, jih bomo v nadaljevanju razdelili na šest kategorij, in sicer:
\begin{itemize}
	\item \textbf{procesni nadzor} -- upravljanje procesov,
	\item \textbf{upravljanje datotek} -- branje in pisanje datotek,
	\item \textbf{upravljanje naprav} -- upravljanje z vhodno-izhodnimi napravami,
	\item \textbf{vzdrževanje informacij o sistemu} -- pridobivanje in urejanje informacij o sistemu,
	\item \textbf{komunikacija med procesi} -- dvosmerna med procesna komunikacija,
	\item \textbf{zaščita} -- upravljanje pravic nad datotekami. \cite{Silberschatz_Galvin_Gagne_2018}
\end{itemize}

\section{Procesni nadzor} \label{sec:process_control}

Proces je program (strojna koda) v izvajanju, katerega status predstavljajo programski števec in vsebina procesorskih registrov.
Proces ima tudi svoj prostor v pomnilniku, ki je običajno razdeljen na več segmentov:
\begin{itemize}
	\item \textbf{podatkovni} (\textit{angl. data}) -- vsebuje vrednosti globalnih spremenljivk,
	\item \textbf{programski} (\textit{angl. text}) -- vsebuje strojno kodo programa,
	\item \textbf{sklad} (\textit{angl. stack}) -- vsebuje vrednosti lokalnih spremenljivk in povratne naslove funkcij in
	\item \textbf{kopica} (\textit{angl. heap}) -- dinamično dodeljen pomnilnik. \cite{Silberschatz_Galvin_Gagne_2018}
\end{itemize}

\begin{figure}[h!]
	\begin{center}
		\begin{tikzpicture}
			\filldraw[fill=blue!20!white] (0, 0) rectangle (4, 8);
			\draw node at (-1, 0) {0};
			\draw node at (-1, 8) {max};
			\filldraw[fill=gray!40!white] (0, 8) rectangle (4, 6.5) node[pos=.5] {stack};
			\draw[arrow] (2, 6.5) -- (2, 5.8);
			\draw[arrow] (2, 3.5) -- (2, 4.2);
			\filldraw[fill=gray!40!white] (0, 2) rectangle (4, 3.5) node[pos=.5] {heap};
			\filldraw[fill=gray!40!white] (0, 1) rectangle (4, 2) node[pos=.5] {data};
			\filldraw[fill=gray!40!white] (0, 0) rectangle (4, 1) node[pos=.5] {text};
		\end{tikzpicture}
	\end{center}
	\caption{Segmenti pomnilnika procesa}
\end{figure}

Sistemski klici za procesni nadzor skrbijo za:
\begin{itemize}
	\item ustvarjanje in uničevanje procesov,
	\item nalaganje in izvajanje programov,
	\item pridobivanje in nastavljanje atributov procesov,
	\item sinhronizacijo procesov,
	\item dodeljevanje in sproščanje pomnilnika. \cite{Silberschatz_Galvin_Gagne_2018}
\end{itemize}

\begin{table}[h!]
	\begin{center}
		\begin{tabular}{ p{3.7cm}|p{2.5cm}|p{6cm} }
			Function          & Linux                                                  & Windows                                                                                                                                                                         \\
			\hline
			Ustvari proces    & \verb|fork|\newline\verb|vfork|                        & \verb|CreateProcess|\newline\verb|CreateProcessAsUser|\newline\verb|CreateProcessWithLogonW|\newline\verb|CreateProcessWithTokenW|                                              \\
			Ustavi proces     & \verb|exit|                                            & \verb|ExitProcess|                                                                                                                                                              \\
			Ubij proces       & \verb|kill|                                            & \verb|TerminateProcess|                                                                                                                                                         \\
			Naloži program   & \verb|execve|                                          & \textit{naloženo pri ustvarjanju}                                                                                                                                              \\
			Sinhronizacija    & \verb|wait|\newline\verb|waitpid|\newline\verb|waitid| & \verb|WaitForSingleObject|\newline\verb|WaitForMultipleObjects|                                                                                                                 \\
			Pridobivanje info & \verb|getpid|\newline\verb|getppid|                    & \verb|GetCurrentProcess|\newline\verb|GetCurrentProcessId|\newline\verb|GetCommandLine|\newline\verb|GetCurrentProcessorNumber|\newline\verb|GetEnvironmentVariable|\newline... \\
		\end{tabular}
	\end{center}
	\label{tab:process_control}
	\caption{Povzetek sistemskih klicev za procesni nadzor}
\end{table}

V tabeli \ref{tab:process_control} vidimo, da je velik del sistemskih klicev za procesni nadzor simetričen med obema operacijskima sistemoma.
Opazimo pa, da Windows ne ponuja sistemskih klicev za nalaganje programov, saj se to zgodi ob ustvarjanju procesa, medtem ko Linux ustvari nov proces s kloniranjem trenutnega procesa in nato omogoča nalaganje drugega programa.
Prav tako opazimo, da Windows ponuja več sistemskih klicev za pridobivanje informacij o procesu, Linux pa te informacije hrani v virtualnem datotečnem sistemu in te informacije za dan proces pridobivamo iz datotek v imeniku \verb|/proc/{pid}/|.

Do glavnih razlik pa pride pri dodeljevanju in sproščanju pomnilnika. Pri lokalnih in globalnih spremenljivkah ni razlik, namreč globalne so shranjene v segmentu podatkov, lokalne pa se nalagajo na sklad.
Seveda pa sklad ni neomejen in zahteva vnaprej definirane velikosti spremenljivk (ob prevajanju v strojno kodo), zato za dinamične spremenljivke uporabljamo kopico.
Za zasedanje kopice pa v Linuxu uporabljamo sistemski klic \verb|brk| in funkcijo \verb|sbrk|, ki premakne konec podatkovnega prostora procesa, kar je precej zapleten proces, namreč od nas zahteva, da sledimo zasedenemu prostoru in ga ročno čistimo ter upravljamo. Linux dokumentacija namesto priporoča uporabo funkcije standardne C knjižnice -- \verb|malloc|, ki pa je precej bolj kompleksna in odvisna od implementacije knjižnice.
V kontrastu nam Windows API ponuja funkcije \verb|GlobalAlloc|, \verb|LocalAlloc|, \verb|HeapAlloc| / \verb|HeapCreate| in \verb|VirtualAlloc| ter pripadajoče sprostitvene funkcije, brez potrebe po zunanji knjižnici in ročnem upravljanju podatkovnega prostora.

\section{Upravljanje datotek}

Za večino uporabnikov je datotečni sistem najbolj viden aspekt operacijskega sistema.
Omogoča hrambo in dostop do podatkov zako za programe operacijskega sistem in uporabnike le tega.
Datotečni sistem je sestavljen iz dveh delov -- datotek in imenikov (oz. imeniške strukture).
Večina datotečnih sistemov biva na sekundarnih pomnilniških napravah, kar bomo podrobneje obravnavali v poglavju \ref{sec:device_management:data_storage}.
Datotečni sistem je odgovoren za hrambo atributov datotek (npr. ime, tip, lokacija, zaščita, velikost, čas zadnje spremembe, itd.) in upravljanje z njimi.

Ko odpremo datoteko, operacijski sistem vrne kazalec na datoteko (Linux: \textit{angl. file descriptor}, Windows: \textit{handle}), ki ga uporabljamo za branje in pisanje datoteke.
Poleg tega pa sistem spremlja tudi število odprtih kazalcev na datoteko, logično lokacijo datoteke in pravice dostopa.
\cite{Silberschatz_Galvin_Gagne_2018}

V UNIX in Linux sistemih je datotečni sistem prerasel svoj prvotni namen in se uporablja tudi za predstavitev naprav, sistemskih virov, ipd.
Primer tega smo videli že v poglavju \ref{sec:process_control}, kjer smo omenili, da se informacije o procesih pridobivajo iz datotek v imeniku \verb|/proc|.

V grobem lahko sistemske klice za upravljanje datotek razdelimo na sledeče kategorije:
\begin{itemize}
	\item ustvarjanje in brisanje datotek,
	\item odpiranje in zapiranje datotek,
	\item branje, pisanje in premikanje datotek,
	\item pridobivanje in nastavljanje atributov datotek. \cite{Silberschatz_Galvin_Gagne_2018}
\end{itemize}

\begin{table}[h!]
	\begin{center}
		\begin{tabular}{ p{3.7cm}|p{2.5cm}|p{6cm} }
			Funkcija           & Linux                                                                                          & Windows                                                           \\
			\hline
			Ustvari            & \verb|creat|\newline\verb|mkdir|                                                               & \verb|CreateFile|\newline\verb|CreateDirectory|                   \\
			Premakni *         & \verb|rename|                                                                                  & \verb|MoveFile|                                                   \\
			Odstrani *         & \verb|unlink|\newline\verb|rmdir|                                                              & \verb|DeleteFile|\newline\verb|RemoveDirectory|                   \\
			Odpri              & \verb|open|                                                                                    & \verb|CreateFile|                                                 \\
			Zapri              & \verb|close|                                                                                   & \verb|CloseHandle|                                                \\
			Beri               & \verb|read|                                                                                    & \verb|ReadFile|                                                   \\
			Piši              & \verb|write|                                                                                   & \verb|WriteFile|                                                  \\
			Premakni kazalnik  & \verb|lseek|                                                                                   & \verb|SetFilePointer|                                             \\
			Pot bližnjice     & \verb|readlink|                                                                                & \verb|GetFinalPathNameByHandle|                                   \\
			Ustvari bližnjico & \verb|link|\newline\verb|symlink|                                                              & \verb|CreateHardLink|\newline\verb|CreateSymbolicLink|            \\
			Zakleni            & \verb|flock|                                                                                   & \verb|LockFile|                                                   \\
			Odkleni            & \verb|flock|                                                                                   & \verb|UnlockFile|                                                 \\
			Pridobi atribute   & \verb|fstat|\newline\verb|stat|\newline\verb|lstat|\newline\verb|utime|\newline\verb|getxattr| & \verb|GetFileInformationByHandle|\newline\verb|GetFileAttributes| \\
			Nastavi atribute   & \verb|setxattr|                                                                                & \verb|SetFileInformationByHandle|\newline\verb|SetFileAttributes| \\
		\end{tabular}
	\end{center}
	\label{tab:file_management}
	\caption{Povzetek sistemskih klicev za upravljanje datotek}
\end{table}

\section{Upravljanje naprav}

Ta kategorija vključuje sistemske klice za:
\begin{itemize}
	\item zahtevanje in sprostitev naprav,
	\item branje, pisanje in premikanje naprav,
	\item pridobivanje in nastavljanje atributov naprav,
	\item logično povezovanje naprav. \cite{Silberschatz_Galvin_Gagne_2018}
\end{itemize}

Tu pričnemo opažati drastične razlike med arhitekturo jeder Linux in Windows.

Linux za upravljanje z napravami namreč uporablja datotečni sistem (VFS), kar pomeni, da lahko naprave odpiramo in z njimi komuniciramo kot z običajnimi datotekami.
Pri direktnem nadzoru naprave oz. ``posebne datoteke'' nam Linux ponuja funkcijo \verb|ioctl|, ki nam omogoča pošiljanje ukazov napravi.
Za večino naprednejših operacij pa nam ponuja sistemski klic \verb|mmap|, ki nam omogoča preslikavo datoteke v pomnilnik in s tem direkten dostop do njenih vsebin.

Za delovanje naprav, ki jih jedro ne podpira, lahko v obeh sistemih uporabimo gonilnike.
Gonilniki so diskretne ``črne škatle'', ki skrijejo podrobnosti implementacije naprave in nam ponudijo enoten vmesnik za upravljanje z napravo.
Uporabniški programi z napravo komunicirajo preko nabora standardiziranih klicev, ki so neodvisni od implementacije gonilnika.
Gonilnik pa nato poveže te klice z dejanskimi operacijami, ki jih mora izvesti naprava.
Programski vmesnik je zastavljen tako, da so lahko gonilniki pripravljeni ločeno in se potem dinamično povežejo z jedrom.
Taka modularnost pomeni, da je pisanje Linux gonilnikov precej enostavno.
\cite{Corbet_Kroah-Hartman_Rubini_2005}

Windows pa za upravljanje z napravami uporablja mnoge posebne funkcije, ki so del Windows API-ja.
Za direktni dostop do naprave pa nam podobno kot Linux ponuja funkcijo \verb|DeviceIoControl|, ki nam omogoča pošiljanje ukazov napravi.

Za gonilnike pa Windows uporablja drugačen pristop.
Sistem namreč podpira več različnih modelov, t. i. ``minidriver model'', za implementacijo gonilnikov, ki so ločeni po kategorijah naprav.
Vsaka kategorija ima svoj vmesnik, ki ga mora gonilnik implementirati.
Uporabniški programi potem komunicirajo z gonilnikom preko tega vmesnika, gonilnik pa nato poskrbi za komunikacijo z napravo.
\cite{MS_Learn_driver_model_2023}

Vidimo, da sam pristop do uporabe naprav ni bistveno drugačen med sistemoma, vendar pa Windows ponuja več različnih načinov za implementacijo gonilnikov, kar istočasno pomeni večjo kompleksnost in potencialno boljšo uporabniško izkušnjo.

\subsection{Naprave za hrambo podatkov} \label{sec:device_management:data_storage}

Masovni pomnilniki (\textit{angl. mass storage}) so naprave, ki omogočajo trajno shranjevanje podatkov -- obstojni pomnilnik (\textit{angl. nonvolatile memory}).
Masovni pomnilnik v modernih sistemih je sekundarni hranilnik, ki ga običajno sestavljajo konvencionalni (magnetni) trdi diski, SSD diski, USB ključki, optični mediji, itd.
Preden je masovna naprava pripravljena za uporabo preko datotečnega sistema, jo moramo najprej razdeliti na eno ali več particij (\textit{angl. partition}), kreirati nosilce (\textit{angl. volume}) -- pri nekaterih datotečnih sistemih je ta korak impliciten, in na koncu formatirati z želenim datotečnim sistemom.
Ko je naprava pripravljena, lahko datotečni sistem uporabljamo za shranjevanje podatkov.
\cite{Silberschatz_Galvin_Gagne_2018}

Linux jedro nam ponuja sistemski klic \verb|mount|, ki nam omogoča povezavo datotečnega sistema z obstoječo potjo v datotečnem sistemu, in klic \verb|umount|, ki nam omogoča zapiranje povezave.
Postopek je relativno preprost, ker Linux uporablja VFS, ki nam omogoča enoten način dostopa do datotek, ne glede na datotečni sistem. To pomeni tudi da imamo samo en korenski imenik \verb|\|.
Vse ostale operacije nad napravo se izvajajo preko datotečnega sistema s klici opisanimi v tabeli \ref{tab:file_management}.

Windows pristop pa je nekoliko bolj zapleten, saj ima vsak nosilec svoj korenski imenik, ki je označen z črko diska (npr. \verb|C:\|, \verb|D:\|, ...), poleg tega pa sistem dovoljuje tudi povezavo nosilca v prazen imenik znotraj obstoječega korenskega imenika (kot Linux).
Za povezavo nosilca nam Windows API ponuja funkcijo \verb|SetVolumeMountPoint|, za odstranitev pa \verb|DeleteVolumeMountPoint|.
Poleg tega nam omogoča tudi poimenovanje nosilca z ukazom \verb|SetVolumeLabel| in druge funkcije za pridobivanje informacij o nosilcu, kot so \verb|GetDriveType|, \verb|FindFirstVolume|, \verb|FindNextVolume|, \verb|FindFirstVolumeMountPoint|,\newline\verb|FindNextVolumeMountPoint|, \verb|GetVolumeInformation|, ...

Zelo podrobno kot za ostale naprave, vidimo, da je Windows API bolj kompleksen in ponuja več funkcij za upravljanje z pomnilniki, med tem ko Linux uporablja peščico sistemskih klicev in se za večino operacij zanaša na VFS.

\section{Vzdrževanje informacij o sistemu}

Ta kategorija vključuje sistemske klice za:
\begin{itemize}
	\item pridobivanje in nastavljanje časa in datuma,
	\item pridobivanje in nastavljanje sistemskih parametrov,
	\item pridobivanje in nastavljanje atributov procesov, datotek in naprav. \cite{Silberschatz_Galvin_Gagne_2018}
\end{itemize}

\begin{table}[h!]
	\begin{center}
		\begin{tabular}{ p{3.7cm}|p{2.5cm}|p{6cm} }
			Function      & Linux   & Windows \\
			\hline
			Pridobi Datum & \verb|| & \verb|| \\
		\end{tabular}
	\end{center}
	\label{tab:information_maintenance}
	\caption{Povzetek sistemskih klicev za vzdrževanje informacij o sistemu}
\end{table}

\section{Komunikacija med procesi}

Ta kategorija vključuje sistemske klice za:
\begin{itemize}
	\item ustvarjanje in uničevanje komunikacijskih poti,
	\item pošiljanje in prejemanje sporočil,
	\item prenos statusov,
	\item povezovanje oddaljenih naprav. \cite{Silberschatz_Galvin_Gagne_2018}
\end{itemize}

\begin{table}[h!]
	\begin{center}
		\begin{tabular}{ p{3.7cm}|p{2.5cm}|p{6cm} }
			Function          & Linux   & Windows \\
			\hline
			Ustvari vtičnico & \verb|| & \verb|| \\
		\end{tabular}
	\end{center}
	\label{tab:communications}
	\caption{Povzetek sistemskih klicev za komunikacijo med procesi}
\end{table}

\section{Zaščita}

Ta kategorija vključuje sistemske klice za pridobivanje in nastavljanje pravic nad datotekami. \cite{Silberschatz_Galvin_Gagne_2018}

\begin{table}[h!]
	\begin{center}
		\begin{tabular}{ p{3.7cm}|p{2.5cm}|p{6cm} }
			Function       & Linux   & Windows \\
			\hline
			Create Process & \verb|| & \verb|| \\
		\end{tabular}
	\end{center}
	\label{tab:protection}
	\caption{Povzetek sistemskih klicev za zaščito}
\end{table}

\chapter{Praktična primerjava}

\section{Metodologija}

Primerjavo izvajamo na identičnih virtualnih sistemih, na Proxmox gostitelju (QEMU), s sledečo konfiguracijo:
\begin{itemize}
	\item i440fx sistemski emulator (UEFI BIOS)
	\item 4 jedra procesorja (Intel\textsuperscript{\textregistered} Core\textsuperscript{\texttrademark} i7-12700H)
	\item 8 GB pomnilnika (Corsair\textsuperscript{\textregistered} Vengeance\textsuperscript{\textregistered} LPX 64GB DDR4 3200 MHz C16)
	\item 100 GB diska (Crucial\textsuperscript{\textregistered} P5 Plus Gen4 NVMe SSD)
\end{itemize}

Za operacijska sistema uporabljamo:
\begin{itemize}
	\item Windows 10 Professional, verzija 22H2, privzeto particioniranje
	\item Ubuntu Desktop 22.04 LTS, privzeto particioniranje (brez LVM)
\end{itemize}
Operacijska sistema sta bila izbrana na podlagi popularnosti in razširjenosti v času pisanja, oba imata namreč največji tržni delež v svoji kategoriji.

Merimo čas izvajanja in število ukazov, ki se morajo izvesti, da pridemo do želenega rezultata.
Za meritev časa program izvedemo dvajsetkrat in izračunamo povprečje, da se izognemo naključnim napakam.

\section{Programi}

\subsection{Procesni nadzor}

\subsection{Upravljanje datotek}

\textbf{Scenarij:}
\begin{enumerate}
	\item Ustvari datoteko \texttt{test.txt} v korenskem imeniku.
	\item Zapiši 500 znakov, vsakega posebej.
	\item Premakni kazalnik v sredino datoteke.
	\item Zapiši še 500 znakov, vsakega posebej.
	\item Premakni kazalnik na začetek datoteke.
	\item Preberi 100 znakov in jih izpiši.
	\item Izpiši atribute datoteke.
	\item Izbriši datoteko.
\end{enumerate}

\textbf{Linux program:}
\lstinputlisting[language=C++]{code/linux/02_files.c}

\textbf{Windows program:}
\lstinputlisting[language=C++]{code/windows/02_files.cpp}

\subsection{Upravljanje naprav}

\subsection{Vzdrževanje informacij o sistemu}

\subsection{Komunikacija med procesi}

\subsection{Zaščita}

\section{Meritve}

\chapter{Zaključek}

%\cleardoublepage
%\addcontentsline{toc}{chapter}{Literatura}

\printbibliography[heading=bibintoc,title={Literatura}]


\end{document}
